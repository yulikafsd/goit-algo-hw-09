# Домашнє завдання 9

У конспекті ми розглянули приклад про розбиття суми на монети. Маємо набір монет [50, 25, 10, 5, 2, 1]. Розробимо систему для касового апарату, яка повинна визначити оптимальний спосіб видачі решти покупцеві.

## Написано дві функції для касової системи, яка видає решту покупцеві:

- Функція жадібного алгоритму find_coins_greedy. Ця функція повинна приймати суму, яку потрібно видати покупцеві, і повертати словник із кількістю монет кожного номіналу, що використовуються для формування цієї суми. Наприклад, для суми 113 це буде словник {50: 2, 10: 1, 2: 1, 1: 1}. Алгоритм повинен бути жадібним, тобто спочатку вибирати найбільш доступні номінали монет. Код виконується і повертає словник з кількістю монет кожного номіналу, що використовуються для формування певної суми. Спочатку вибираються найбільш доступні номінали монет.

- Функція динамічного програмування find_min_coins. Ця функція також повинна приймати суму для видачі решти, але використовувати метод динамічного програмування, щоб знайти мінімальну кількість монет, необхідних для формування цієї суми. Функція повинна повертати словник із номіналами монет та їх кількістю для досягнення заданої суми найефективнішим способом. Наприклад, для суми 113 це буде словник {1: 1, 2: 1, 10: 1, 50: 2}. Код виконується і повертає словник з номіналами монет та їх кількістю для досягнення заданої суми найефективнішим способом.

## Висновки:

Порівняймо ефективність жадібного алгоритму та алгоритму динамічного програмування, базуючись на часі їх виконання або О великому та звертаючи увагу на їхню продуктивність при великих сумах.

### Жадібний алгоритм

Працює за принципом вибору найбільшого можливого номіналу монети на кожному кроці.
- Часова складність: O(n), де n — кількість номіналів монет. Фактичний час для суми 113 та масиву [50, 25, 10, 5, 2, 1] - 0.005 ms.
- Памʼять: O(1)
- Переваги: дуже швидкий, простий у реалізації
- Недоліки: не завжди гарантує оптимальне рішення для довільних наборів монет

### Алгоритм динамічного програмування
Знаходить мінімальну кількість монет для кожної суми від 0 до заданої.
- Часова складність: O(amount × n). Фактичний час для суми 113 та масиву [50, 25, 10, 5, 2, 1] - 0.042 ms.
- Памʼять: O(amount)
- Переваги: завжди знаходить оптимальне рішення
- Недоліки: значно повільніший і використовує більше памʼяті при великих сумах

### Висновок
Для даного набору монет жадібний алгоритм є більш ефективним і практичним рішенням, оскільки він працює швидше та використовує менше памʼяті, при цьому даючи оптимальний результат. Алгоритм динамічного програмування доцільно використовувати у випадках, коли набір номіналів не гарантує оптимальності жадібного підходу.